---
title: "Malaise trap dilution experiment"
author: "Mingjie"
date: "7/5/2021"
output: html_document
---


```{r setup, eval=TRUE, include=FALSE}
# script-specific packages
#install.packages("broom.mixed")
#install.packages("MuMIn")
#install.packages("sjPlot")
#install.packages("equatiomatic")
#install.packages("lmerTest")

suppressPackageStartupMessages({
  library(sjPlot)
  library(broom.mixed)
  library(MuMIn)
  library(equatiomatic)
  library(lmerTest) # also loads lme4
  library(mvabund)
})

# general-use packages
suppressPackageStartupMessages({
  library(tidyverse)
  library(here)
  library(fs)
  library(glue)
  library(readxl)
  library(cowplot)
  library(lubridate)
  library(patchwork)
  library(broom)
  library(ggeffects)
  library(viridis)
  library(arsenal) # for tableby()
  library(waldo) # for compare()
  library(sjmisc) # for rotate_df()
  library(envDocument) #not available 
  library(inspectdf)
  library(conflicted)
  library(knitr)
  library(beepr)
  library(pivottabler)
  library(furrr)
  library(scales)
  library(janitor)
  library(tictoc)
  library(DataExplorer)
  library(ragg)
})

# Sometimes, two or more packages use the same function names. The {conflicted} package lets you set which package gets precedence. For example, the next line enforces that filter() refers to the {dplyr} package. If you want to use the command filter() from a different package, you just need to precede it with the desired package name like this: stats::filter.
conflict_prefer("mutate", "dplyr", quiet = TRUE)
conflict_prefer("select", "dplyr", quiet = TRUE)
conflict_prefer("summarise", "dplyr", quiet = TRUE)
conflict_prefer("filter", "dplyr", quiet = TRUE)
conflict_prefer("first", "dplyr", quiet = TRUE)
conflict_prefer("here", "here", quiet = TRUE)
conflict_prefer("separate", "tidyr", quiet = TRUE)
conflict_prefer("unite", "tidyr", quiet = TRUE)
conflict_prefer("trim", "sjmisc", quiet=TRUE)
conflict_prefer("rescale", "scales", quiet=TRUE)
conflict_prefer("intersect", "dplyr", quiet = TRUE)
conflict_prefer("setdiff", "dplyr", quiet = TRUE) # w/out this, R crashes
conflict_prefer("to_factor", "sjmisc", quiet = TRUE)
conflict_prefer("trim", "glue", quiet = TRUE)
conflict_prefer("discard", "purrr", quiet = TRUE)
conflict_prefer("extract", "tidyr", quiet = TRUE)
conflict_prefer("lmer", "lme4", quiet = TRUE)
conflict_prefer("col_facotr", "scales")

# R version
R.version.string
# Print real numbers, not scientific notation.
options(scipen = 999)
```

```{r read data}
dd <- read.csv(here('data','Malaise-trap_Samples_20211228.csv'), header = T)
str(dd)
```


```{r}
dd$log.inputDNA <- log(dd$inputDNA)
dd$log.OTUsize <- log(dd$OTUsize)
dd$log.FSL <- log(dd$FSL)

plot_missing(dd)
plot_histogram(dd)
```

 [1] "OTU"                    "sampleName"             "OTUsize"               
 [4] "dilution"               "sample"                 "readSpikeSum"          
 [7] "inputDNA"               "added.lysis.buffer.ml." "WEIGHT.g."             
[10] "period"                 "lysis.batch"            "aliquot"               
[13] "lysisBufferFrac"        "FSL"                    "sample2"               
[16] "fittedOTUsize"          "fittedFSL"              "log.inputDNA"          
[19] "log.OTUsize"            "log.FSL"        

variable names
OTU: species
sampleName:  Malaise trap and dilution 
OTUsize:  number of reads per OTU in that sample and dilution level, uncorrected for pipeline noise
dilution:  dilution level (A is undiluted, F is most diluted)
sample:  Malaise trap
readSpikeSum:  number of spike-in reads, summed over the two spike-in species
inputDNA: scales the dilution
added.lysis.buffer.ml.

```{r spike-corrected FSL}
# lmer1 <- lmer(log.inputDNA ~ log.FSL + (1 | sample), data = dd, 
#               REML = F)
# summary(lmer1)
# plot(lmer1)
# 
# lmer2 <-lmer(log.inputDNA ~ log.FSL + (1 | OTU), data = dd, REML = F)
# summary(lmer2)
# plot(lmer2)

lmer3 <- lmer(log.inputDNA ~ log.FSL + (1 | sample/OTU), 
              data = dd, REML = F)
summary(lmer3)
plot(lmer3)

lmer4<- lmer(log.inputDNA ~ log.FSL +(log.FSL | sample/OTU), 
             data = dd, REML = F)
summary(lmer4) 
# singular fit
plot(lmer4)

AIC(lmer3, lmer4) # lmer4 has lowest AIC 

ranova(lmer3) # keep both random intercepts
ranova(lmer4) # remove random slope log.FSL since its p-value is 0.02, and it accounts for only a small amount of variation, leading to a singularity error during fitting
# keep lmer3

# test if we can remove fixed effect log.FSL
lmer5 <- lmer(log.inputDNA ~ 1 + (1 | sample/OTU), 
              data = dd, REML = F)
summary(lmer5)
# singular fit
plot(lmer5)

AIC (lmer3, lmer5) # 
anova(lmer4, lmer5) # two models are highly sig different, keep log.FSL fixed effect

model.final <- lmer(log.inputDNA ~ log.FSL + (1 | sample/OTU),
                    data = dd, REML = T)

summary(model.final)
AIC(model.final)

r.squaredGLMM(model.final) #0.53, 0.98

pred.mm <- ggpredict(model.final, terms = c("log.FSL[all]"))

dd$sample2 <-  str_replace_all(dd$sample, c("123545.M1.S1" = "Sample 1", "124031.M1.S1" = "Sample 2", "286789.M1.S1" = "Sample 3", "357256.M2.S1" = "Sample 4", "700239.M1.S1" = "Sample 5", "HB.053.M1.S1" = "Sample 6", "HB.216.M1.S1" = "Sample 7"))

(p1 <- ggplot() +
  geom_line(data = pred.mm, aes(x = x, y = predicted), 
            colour = "black", size = 1) +
  geom_ribbon(data = pred.mm, aes(x = x, ymin = predicted - std.error, 
                                  ymax = predicted + std.error), 
              fill = "lightgrey", alpha = 0.5) +
  geom_point(data = dd, aes( x = log.FSL, y = log.inputDNA, colour = OTU), 
             size = 0.8) +
  geom_smooth(data = dd, aes( x = log.FSL, y = log.inputDNA, group = OTU),
              method = "lm", se = FALSE, size = 0.1, colour = "black", 
              alpha = 0.5, linetype = 1) +
  labs(x = "log(spike-corrected OTU size)", y = "log(input genomic DNA mass)") +
  theme_cowplot() +
  theme(legend.position = "none") + 
  facet_wrap(~sample2) +
  coord_cartesian(ylim = c(-2.0, 0.25)) +
  scale_y_continuous(breaks = seq(-2.5, 0.5, 0.5)))
```


```{r non-spike-corrected OTU size }
# lmer_otusize1 <- lmer(log.inputDNA ~ log.OTUsize + (1| sample), data = dd, 
#                       REML = F )
lmer_otusize2 <- lmer(log.inputDNA ~ log.OTUsize + (1| sample/OTU), data = dd,
                      REML = F)
summary(lmer_otusize2)
lmer_otusize3 <- lmer(log.inputDNA ~ log.OTUsize + (log.OTUsize | sample/OTU), 
                      data =dd, REML = F)
summary(lmer_otusize3)
# singular fit
# ranova(lmer_otusize1) # remove random factor
ranova(lmer_otusize2) # remove random factor
ranova(lmer_otusize3) # remove random factor
# the random factors should be omitted from the model, but sample/OTU are part of the design, so i have to keep those two

# test fixed effect 
lmer_otusize4 <- lmer(log.inputDNA ~ 1 + (1 | sample/OTU), 
                      data =dd, REML = F)
anova(lmer_otusize3, lmer_otusize4) # fixed effect log.OTUsize not sig, p = 0.534

# parameter estimate REML=T and including the non-sig log.inputDNA to get an estimate of the low R2 value
lmer_otusize5 <- lmer(log.inputDNA ~ log.OTUsize + (1 | sample/OTU), 
                      data =dd, REML = T)
summary(lmer_otusize5) 
r.squaredGLMM(lmer_otusize5) # 0.0002 0.0002

pred.mm1 <- ggpredict(lmer_otusize5, terms = c("log.OTUsize[all]"))

(p2 <- ggplot() +
  geom_line(data = pred.mm1, aes(x = x, y = predicted), 
            colour = "black", size = 1) +
  # geom_smooth(data = dd, aes(x = log.OTUsize, y = log.inputDNA), 
  #           method = "lm", se = FALSE, colour = "black", size = 1) +
  geom_point(data = dd, aes(x = log.OTUsize, y = log.inputDNA, 
                             colour = OTU), size = 0.8) +
  geom_smooth(data = dd, aes(x = log.OTUsize, y = log.inputDNA, group = OTU),
              method = "lm", se = FALSE, size = 0.1, colour = "black", 
              alpha = 0.5, linetype = 1) +
  labs(x = "log(non-spike-corrected OTU size)", 
       y = "log(input genomic DNA mass)") +
  theme_cowplot() + 
  theme(legend.position = "none") + 
  coord_cartesian(ylim = c(-2.0, 0)) +
  facet_wrap(~sample2))
```

```{r}
p2 | p1 + plot_annotation(tag_levels = 'A')
```

#### Model-based pipeline-noise estimation: offset0 (Ã£ from Eq. 2)

```{r reformat to dd2}
dd2 <- dd %>% 
  select(OTUsize, dilution, sample, OTU, readSpikeSum, inputDNA) %>% 
  pivot_wider(names_from = OTU, values_from = OTUsize, values_fill = 0) 

otu <- dd2 %>% 
  select(starts_with("OTU"))

X <- dd2 %>% 
  select(!starts_with("OTU"))
```


```{r calculate offset0 for mydata2}
otu <- mvabund(otu)

# fit0 <- manyglm(otu ~ 1, family = "negative.binomial") # if no predictors
fit0 <- manyglm(otu ~ dilution, family = "negative.binomial", data = X) 
# The same OTU can appear in more than one sample (i.e. the 7 Malaise traps), with presumably different starting abundances per sample before being diluted, so we include a sample term. 
plot(fit0)

# fit0 <- manyglm(otu ~ soup, family = binomial("cloglog")) # for p/a data
offset0 <- log(rowSums(otu)) - log(rowSums(fitted(fit0))) 
dd2$offset0 <- offset0
dd3 <- dd2 %>% 
  pivot_longer(cols = starts_with("OTU"), 
               names_to = "OTU", 
               values_to = "readNum") %>% 
  mutate(readNumOffsetCorr = readNum / exp(offset0)) %>% # correction 
  relocate(sample, dilution, OTU, readSpikeSum, offset0, readNum, readNumOffsetCorr) 
  

# offset0 is not correlated with spike-in readNum
ggplot(data = dd3, aes(x = offset0, y = log(readSpikeSum), group = sample, 
                       colour = sample)) +
  geom_point() +
  geom_smooth(method = "lm", se = FALSE, size = 1, 
              alpha = 0.5, linetype = 1) +
  labs(x = "offset0", y = "ln(readSpike)") +
  theme_cowplot() +
  theme(legend.position = "right")

summary(lm(log(readSpikeSum) ~ offset0, data = dd3))
# R2 = 0.03062
```
